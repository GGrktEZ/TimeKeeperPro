import type { DayEntry, Project, WorkSession } from "./types"

/**
 * Export weekly time entries into a Dynamics 365 CRM Excel template.
 *
 * Dynamics 365 uses hidden metadata sheets for field mapping.
 * We load the user's template file, clear existing data rows on the
 * first (visible) sheet, and append our generated rows -- preserving
 * all hidden sheets so Dynamics accepts the import.
 *
 * Uses SheetJS (xlsx) loaded from CDN to avoid bundling a large dependency.
 */

// Column headers in order as they appear in the Dynamics 365 export
const HEADERS = [
  "(Do Not Modify) Time Entry",
  "(Do Not Modify) Row Checksum",
  "(Do Not Modify) Modified On",
  "Time Source",
  "Project",
  "Project Task",
  "Role",
  "Type",
  "Subcontract",
  "Subcontract line",
  "Entry Status",
  "Date",
  "Duration",
  "Description",
  "External Comments",
  "Generated by AI",
  "Created By",
] as const

type TimeRow = Record<(typeof HEADERS)[number], string>

function formatDateDMY(dateStr: string): string {
  const [y, m, d] = dateStr.split("-")
  return `${d}/${m}/${y}`
}

function sessionMinutes(session: WorkSession): number {
  if (!session.start || !session.end) return 0
  const [sH, sM] = session.start.split(":").map(Number)
  const [eH, eM] = session.end.split(":").map(Number)
  const d = (eH * 60 + eM) - (sH * 60 + sM)
  return d > 0 ? d : 0
}

export interface ExportOptions {
  entries: DayEntry[]
  projects: Project[]
  weekDates: string[]
  createdBy?: string
  role?: string
}

/**
 * Build export rows. Sessions on the same project+date+task are merged.
 */
export function buildExportRows(options: ExportOptions): TimeRow[] {
  const { entries, projects, weekDates, createdBy = "", role = "" } = options
  const projectMap = new Map(projects.map((p) => [p.id, p]))
  const rows: TimeRow[] = []

  const grouped = new Map<string, Map<string, Map<string, { minutes: number; descriptions: string[] }>>>()

  for (const date of weekDates) {
    const entry = entries.find((e) => e.date === date)
    if (!entry) continue
    for (const dp of entry.projects ?? []) {
      for (const session of dp.workSessions ?? []) {
        const mins = sessionMinutes(session)
        if (mins <= 0) continue
        const taskKey = session.taskName ?? ""
        if (!grouped.has(date)) grouped.set(date, new Map())
        const dateMap = grouped.get(date)!
        if (!dateMap.has(dp.projectId)) dateMap.set(dp.projectId, new Map())
        const projMap = dateMap.get(dp.projectId)!
        if (!projMap.has(taskKey)) projMap.set(taskKey, { minutes: 0, descriptions: [] })
        const agg = projMap.get(taskKey)!
        agg.minutes += mins
        if (session.doneNotes?.trim()) agg.descriptions.push(session.doneNotes.trim())
      }
    }
  }

  for (const [date, dateMap] of grouped) {
    for (const [projectId, projMap] of dateMap) {
      const project = projectMap.get(projectId)
      const projectName = project?.name ?? "Unknown"
      for (const [taskName, agg] of projMap) {
        const row: TimeRow = {
          "(Do Not Modify) Time Entry": "",
          "(Do Not Modify) Row Checksum": "",
          "(Do Not Modify) Modified On": "",
          "Time Source": "Project Service",
          "Project": projectName,
          "Project Task": taskName,
          "Role": role,
          "Type": "Work",
          "Subcontract": "",
          "Subcontract line": "",
          "Entry Status": "Draft",
          "Date": formatDateDMY(date),
          "Duration": String(agg.minutes),
          "Description": agg.descriptions.join("; "),
          "External Comments": "",
          "Generated by AI": JSON.stringify({
            created_by: "TimeKeeperPro",
            source: "export",
          }),
          "Created By": createdBy,
        }
        rows.push(row)
      }
    }
  }

  rows.sort((a, b) => {
    const dateCompare = a["Date"].split("/").reverse().join("").localeCompare(
      b["Date"].split("/").reverse().join("")
    )
    if (dateCompare !== 0) return dateCompare
    return a["Project"].localeCompare(b["Project"])
  })

  return rows
}

// --- SheetJS CDN loader ---

// eslint-disable-next-line @typescript-eslint/no-explicit-any
let xlsxPromise: Promise<any> | null = null

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function loadXlsx(): Promise<any> {
  if (xlsxPromise) return xlsxPromise
  xlsxPromise = new Promise((resolve, reject) => {
    const script = document.createElement("script")
    script.src = "https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"
    script.onload = () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const XLSX = (window as any).XLSX
      if (XLSX) resolve(XLSX)
      else reject(new Error("Failed to load SheetJS"))
    }
    script.onerror = () => reject(new Error("Failed to load SheetJS CDN"))
    document.head.appendChild(script)
  })
  return xlsxPromise
}

// --- Template-based export (preserves hidden Dynamics sheets) ---

/**
 * Read an uploaded Dynamics 365 template file, clear existing data rows
 * on the first visible sheet, and append our rows. Returns a downloadable blob.
 */
export async function exportToExcelWithTemplate(
  templateFile: File,
  rows: TimeRow[],
  filename: string
): Promise<void> {
  const XLSX = await loadXlsx()

  // Read the template workbook, preserving hidden sheets
  const buf = await templateFile.arrayBuffer()
  const wb = XLSX.read(buf, { type: "array", cellStyles: true })

  // The first sheet is the visible data sheet
  const sheetName = wb.SheetNames[0]
  const ws = wb.Sheets[sheetName]

  // Find the header row (row 1) to get column mapping
  const range = XLSX.utils.decode_range(ws["!ref"] || "A1")
  const colMap: Record<string, number> = {}

  for (let c = range.s.c; c <= range.e.c; c++) {
    const cellAddr = XLSX.utils.encode_cell({ r: 0, c })
    const cell = ws[cellAddr]
    if (cell && cell.v) {
      colMap[String(cell.v)] = c
    }
  }

  // Clear all existing data rows (keep row 0 = headers)
  for (let r = 1; r <= range.e.r; r++) {
    for (let c = range.s.c; c <= range.e.c; c++) {
      const addr = XLSX.utils.encode_cell({ r, c })
      delete ws[addr]
    }
  }

  // Write our new rows starting at row 1
  for (let ri = 0; ri < rows.length; ri++) {
    const row = rows[ri]
    for (const header of HEADERS) {
      const col = colMap[header]
      if (col === undefined) continue
      const addr = XLSX.utils.encode_cell({ r: ri + 1, c: col })
      ws[addr] = { t: "s", v: row[header] }
    }
  }

  // Update the sheet range
  const newRange = {
    s: { r: 0, c: range.s.c },
    e: { r: Math.max(rows.length, 0), c: range.e.c },
  }
  ws["!ref"] = XLSX.utils.encode_range(newRange)

  // Write and download
  const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" })
  const blob = new Blob([wbOut], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" })
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a")
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

/**
 * Fallback: generate a fresh Excel file (won't work for Dynamics import,
 * but useful as a standalone spreadsheet).
 */
export async function exportToExcelFresh(rows: TimeRow[], filename: string): Promise<void> {
  const XLSX = await loadXlsx()
  const ws = XLSX.utils.json_to_sheet(rows)
  ws["!cols"] = HEADERS.map(() => ({ wch: 24 }))
  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, "Time Entries")
  XLSX.writeFile(wb, filename)
}
