import type { DayEntry, Project, WorkSession } from "./types"

/**
 * Export weekly time entries as an Excel (.xlsx) file
 * matching the Dynamics 365 CRM time entry import format.
 *
 * Uses SheetJS (xlsx) loaded from CDN to avoid bundling a large dependency.
 */

interface TimeRow {
  "(Do Not Modify) Time Entry": string
  "(Do Not Modify) Row Checksum": string
  "(Do Not Modify) Modified On": string
  "Time Source": string
  "Project": string
  "Project Task": string
  "Role": string
  "Type": string
  "Subcontract": string
  "Subcontract line": string
  "Entry Status": string
  "Date": string
  "Duration": string
  "Description": string
  "External Comments": string
  "Generated by AI": string
  "Created By": string
}

function formatDateDMY(dateStr: string): string {
  // dateStr is "yyyy-MM-dd", convert to "DD/MM/YYYY"
  const [y, m, d] = dateStr.split("-")
  return `${d}/${m}/${y}`
}

function sessionMinutes(session: WorkSession): number {
  if (!session.start || !session.end) return 0
  const [sH, sM] = session.start.split(":").map(Number)
  const [eH, eM] = session.end.split(":").map(Number)
  const d = (eH * 60 + eM) - (sH * 60 + sM)
  return d > 0 ? d : 0
}

export interface ExportOptions {
  entries: DayEntry[]
  projects: Project[]
  weekDates: string[] // yyyy-MM-dd format
  createdBy?: string
  role?: string
}

/**
 * Build the rows for the export. Each work session becomes one row.
 * Sessions on the same project+date+task are merged into one row.
 */
export function buildExportRows(options: ExportOptions): TimeRow[] {
  const { entries, projects, weekDates, createdBy = "", role = "" } = options

  const projectMap = new Map(projects.map((p) => [p.id, p]))
  const rows: TimeRow[] = []

  // Group: date -> projectId -> taskName -> { minutes, descriptions }
  const grouped = new Map<string, Map<string, Map<string, { minutes: number; descriptions: string[] }>>>()

  for (const date of weekDates) {
    const entry = entries.find((e) => e.date === date)
    if (!entry) continue

    for (const dp of entry.projects ?? []) {
      for (const session of dp.workSessions ?? []) {
        const mins = sessionMinutes(session)
        if (mins <= 0) continue

        const taskKey = session.taskName ?? ""
        if (!grouped.has(date)) grouped.set(date, new Map())
        const dateMap = grouped.get(date)!
        if (!dateMap.has(dp.projectId)) dateMap.set(dp.projectId, new Map())
        const projMap = dateMap.get(dp.projectId)!
        if (!projMap.has(taskKey)) projMap.set(taskKey, { minutes: 0, descriptions: [] })
        const agg = projMap.get(taskKey)!
        agg.minutes += mins
        if (session.doneNotes?.trim()) {
          agg.descriptions.push(session.doneNotes.trim())
        }
      }
    }
  }

  // Flatten grouped data into rows
  for (const [date, dateMap] of grouped) {
    for (const [projectId, projMap] of dateMap) {
      const project = projectMap.get(projectId)
      const projectName = project?.name ?? "Unknown"

      for (const [taskName, agg] of projMap) {
        const row: TimeRow = {
          "(Do Not Modify) Time Entry": "",
          "(Do Not Modify) Row Checksum": "",
          "(Do Not Modify) Modified On": "",
          "Time Source": "Project Service",
          "Project": projectName,
          "Project Task": taskName,
          "Role": role,
          "Type": "Work",
          "Subcontract": "",
          "Subcontract line": "",
          "Entry Status": "Draft",
          "Date": formatDateDMY(date),
          "Duration": String(agg.minutes),
          "Description": agg.descriptions.join("; "),
          "External Comments": "",
          "Generated by AI": JSON.stringify({
            created_by: "TimeKeeperPro",
            source: "export",
          }),
          "Created By": createdBy,
        }
        rows.push(row)
      }
    }
  }

  // Sort by date then project
  rows.sort((a, b) => {
    const dateCompare = a["Date"].split("/").reverse().join("").localeCompare(
      b["Date"].split("/").reverse().join("")
    )
    if (dateCompare !== 0) return dateCompare
    return a["Project"].localeCompare(b["Project"])
  })

  return rows
}

// Dynamically load SheetJS from CDN
let xlsxPromise: Promise<typeof import("xlsx")> | null = null

function loadXlsx(): Promise<typeof import("xlsx")> {
  if (xlsxPromise) return xlsxPromise
  xlsxPromise = new Promise((resolve, reject) => {
    const script = document.createElement("script")
    script.src = "https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"
    script.onload = () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const XLSX = (window as any).XLSX
      if (XLSX) resolve(XLSX)
      else reject(new Error("Failed to load SheetJS"))
    }
    script.onerror = () => reject(new Error("Failed to load SheetJS CDN"))
    document.head.appendChild(script)
  })
  return xlsxPromise
}

export async function exportToExcel(rows: TimeRow[], filename: string): Promise<void> {
  const XLSX = await loadXlsx()

  const ws = XLSX.utils.json_to_sheet(rows)

  // Set column widths for readability
  ws["!cols"] = [
    { wch: 38 }, // Time Entry
    { wch: 38 }, // Row Checksum
    { wch: 22 }, // Modified On
    { wch: 16 }, // Time Source
    { wch: 40 }, // Project
    { wch: 40 }, // Project Task
    { wch: 16 }, // Role
    { wch: 8 },  // Type
    { wch: 12 }, // Subcontract
    { wch: 16 }, // Subcontract line
    { wch: 12 }, // Entry Status
    { wch: 12 }, // Date
    { wch: 10 }, // Duration
    { wch: 40 }, // Description
    { wch: 20 }, // External Comments
    { wch: 30 }, // Generated by AI
    { wch: 20 }, // Created By
  ]

  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, "Time Entries")
  XLSX.writeFile(wb, filename)
}
